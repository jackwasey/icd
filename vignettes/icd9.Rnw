%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Using icd9}

\documentclass{article}

\title{Introducing icd9: working with ICD-9 codes and comorbidities in R}
\author{Jack O. Wasey}

\begin{document}

\maketitle

<<setup, eval=TRUE, echo=FALSE>>=

set.seed = 1441

#oldOpt <- options(width = 20) # prevent stupid hbox overflows.
#on.exit(options(oldOpt))

suppressMessages(library(icd9, quietly = TRUE, warn.conflicts = FALSE))
suppressMessages(library("magrittr", quietly = TRUE, warn.conflicts = FALSE))

patientData <- data.frame(
  visitId = c(1000, 1000, 1000, 1001, 1001, 1002),
  icd9 = c("27801", "7208", "25001", "34400", "4011", "4011"),
  poa = factor(c("Y", "N", "Y", "N", "Y", "N"))
)
@

\section{Introduction}

This package is designed to be used with a variety of input data, including multiple possible formats of ICD-9 codes, but some assumptions are made. There are many ways of misinterpreting ICD-9 codes, especially when dealing with ranges. The code in this package carefully considers a wide range of possibilities. \textbf{ICD-9 codes are not numeric}. Using numeric values for either decimal or non-decimal form will cause serious problems, hence the predominantly string-based processing here, and a robust set of unit tests.

When calcuating which patients have which comorbidities, the input data is typically structured as follows:

<<begin, eval=TRUE>>=
patientData
@

Only the visitId column is propogated to the results. If 'present-on-arrival' is needed, it must be separated out first. The implicit default, therefore, is to ignore it, and give ICD-9 code regardless of POA status.

The comorbidities can be determined as follows:
<<getcomorbidities, eval=TRUE>>=
icd9Comorbidities(icd9df = patientData)[, 1:5]
@
or using magrittr to chain functions together:
<<getcomorbidities, eval=TRUE>>=
patientData %>%
  icd9FilterPoaNotNo() %>%
  icd9ComorbiditiesAhrq(isShort = TRUE) %>%
  extract(1:5)
@

The following shows the same code with default options written out:
<<echo=TRUE,eval=FALSE>>=
icd9Comorbidities(icd9df = patientData,
                  visitId = "visitId",
                  icd9Field = "icd9",
                  icd9Mapping = ahrqComorbid,
                  validateMapping = FALSE,
                  shortMapping = TRUE)
@

\section{Converting ICD-9 codes between types}
These functions were designed with the problem of incorrectly or bizarrely formatted ICD-9 codes in mind. These functions make the reasonable assumption that short codes of three or fewer characters must be describing only the 'major' part. \begin{verbatim}keepLoneDecimal\end{verbatim} allows retention of the decimal point even if there are no subsequent characters.

<<conversion,eval=T>>=
icd9DecimalToShort(c("10.20", "100", "123.45"))
icd9ShortToDecimal(icd9DecimalToShort(c("10.20", "100", "123.45")))

# only a subset of short codes can suffer dropping of leading zeroes.
icd9DecimalToShort(c("1", "22", "22.44", "100"))

icd9ShortToDecimal(icd9DecimalToShort(c("1", "1.2", "123.45")))

icd9ShortToDecimal(icd9DecimalToShort(c("1", "2.2", "100")))
@

\section{Validation of ICD-9 codes}
<<validation,eval=T>>=
icd9ValidDecimal("V10.2")
icd9ValidShort(c("099.17", "-1"))
icd9ValidShort(c("1", "001", "100", "10023"))
@

Validation forces the package user to provide character format ICD-9 codes. If great care is taken, passing some integers could be valid, but given the high chance of mistakes, and the simplicity of dealing entirely with character input, character is enforced:
<<invalidint,eval=F>>=
icd9ValidShort(100) # throws an error
@

\section{Ranges of ICD-9 codes}

These functions generate syntactically valid ICD-9 codes, without including parent codes when the range limit would subset the parent. E.g. "100.99" \%i9d\% "101.01" does not include "100" or "100.0", both of which imply large subsets than requested by the range command.

<<ranges,eval=T>>=
"10099" %i9s% "10101"
"V10" %i9d% "V10.02"
# "E987" %i9d% "E988.9"
@

Another way of specifying ranges are to use function calls. These are exactly equivalent to the \%i9s\% and \%i9d\% range operators. This example shows the result when the user specifies a range which would include parents but not all their children:
<<rangeanomaly>>=
icd9ExpandRangeShort("V100", "V1002")
@
Although V100 would include ten children, the range only returns 4 values. In all other cases, parents are omitted to avoid the range returning overly broad classifications than intended. A planned feature is to optionally enable returning these parent codes, which would then follow a more numerical pattern (although still distinguishing trailing zeroes).

\section{Human-readable ICD-9}
<<explain,eval=T>>=
icd9ExplainDecimal("1.0")
icd9Explain("1.0", isShort = FALSE)
icd9ExplainDecimal("001.1")
icd9ExplainDecimal(icd9ShortToDecimal("0019"))
icd9ExplainShort("0019")
# named list(s) of codes
icd9ExplainDecimal(list(cholera = c("001", "001.0", "001.1", "001.9")))
# same using decimal codes without a list
icd9ExplainDecimal(c("001", "001.0", "001.1", "001.9"))

# 001/cholera doesn't itself have an explanation: TODO walk down children to get next level explanations.
icd9ExplainDecimal(list(cholera = "001", rheumatic_heart = "390"))


@
Now try to explain on a non-existent (but 'valid') ICD-9 code:
<<noexplain,eval=T>>=
icd9ExplainDecimal("001.5")
@
icd9ExplainDecimal(list(cholera=c("001.0", "001.1", "001.9")))
@

\section{Chaining commands}
With the \begin{verbatim}magrittr\end{verbatim} package installed, commands can be chained together in a convenient and readable manner:
<<chaining1,eval=T>>=
c("001.1", "391") %>% icd9DecimalToShort %>% icd9ExplainShort
@

Find all ICD-9 codes matching 'heart' or 'cardiac' in the short or long descriptions:
<<>>=
cardiac <- unique(c(
  icd9CmDesc[
    grepl(
      pattern="(heart)|(cardiac)",
      x = icd9CmDesc[["descLong"]],
      ignore.case = TRUE
    ),
    "icd9"],
  icd9CmDesc[
    grepl(
      pattern="(heart)|(cardiac)",
      x = icd9CmDesc[["descShort"]],
      ignore.case = TRUE
    ),
    "icd9"]
))
@
then explain the list, just showing the first ten:
<<eval=TRUE,echo=TRUE>>=
cardiac %>% icd9ExplainShort %>% extract(2) %>% head(10)
@

More examples, this time also demonstrating automatic summarization of a long list of ICD-9 codes into the minimum set of explanatory parent codes:
<<eval=TRUE,echo=TRUE>>=
quanDeyoComorbid[["Dementia"]] %>%
  icd9ExplainShort() %>%
  extract(c("ICD-9","Description"))

# use a range with more than two hundred ICD-9 codes

length("390" %i9d% "392.1")
"390" %i9d% "392.1" %>% icd9DecimalToShort() %>% icd9ExplainShort()
"390" %i9d% "392.1" %>% icd9ExplainDecimal()

@

\section{Filtering from Present-on-Arrival}
Present-on-arrival (POA) is typically a factor, or vector of values such as "Y", "N", "X", "E", or NA. Intermediate codes, such as "exempt", "unknown" and NA mean that "yes" is not the same as "not no." This requires four functions to cover the possibilities stored in icd9PoaChoices:
<<eval=TRUE,echo=TRUE>>=
icd9PoaChoices
@

Magrittr allows chaining of the filtering very nicely:
<<eval=TRUE,echo=TRUE>>=
myData <- data.frame(
  visitId = c("v1", "v2", "v3", "v4"),
  icd9 = c("39891", "39790", "41791", "4401"),
  poa = c("Y", "N", NA, "Y"),
  stringsAsFactors = FALSE)
myData
myData %>% icd9FilterPoaYes() %>% extract(1:7)
myData %>% icd9FilterPoaNotNo() %>% extract(1:7)
myData %>%
  icd9FilterPoaNotNo() %>%
  icd9ComorbiditiesAhrq(isShort = TRUE) %>%
  extract(1:7)
@
This is showing off how magrittr works in the context of this package: Fill out some named fields:
<<>>=

myData %>% icd9FilterPoaYes(poaField="poa") %>%
  icd9ComorbiditiesAhrq(visitId = "visitId") %>%
  extract(1:7)
@
Call the core icd9Comorbidities function with an arbitrary mapping
<<>>=
myData %>%
  icd9FilterPoaYes() %>%
  icd9Comorbidities(
    icd9Field = "icd9", visitId = "visitId",
    icd9Mapping = quanElixhauserComorbid,
    validateMapping = TRUE, isShortMapping = TRUE
  )  %>%
  extract(1:7)
@

\section{AHRQ comorbidity classification}

The AHRQ keeps an updated version of the Elixhauser classification of ICD-9-CM codes into comorbidities, useful for research. They provide the data in the form of SAS code. This package provides just enough code to parse the SAS source code provided by the AHRQ (but probably not much other SAS code), and generate a list of ICD-9 codes for each comorbidity.

<<ahrq,eval=F>>=
ahrqComorbid <- parseAhrqSas()
@

<<ahrqcontents>>=
head(summary(ahrqComorbid))
@

Here are a couple of the shorter ICD-9 groups listed in ahrqComorbid:

<<echo=FALSE>>=
options(width = 55)
@

SAS source code has a strong whiff of the 1970s about it.
A fragment of a recent AHRQ SAS comorbidity mapping SAS FORMAT is as follows. Note the mix of character and numeric-only ranges, isolated values, all in 'short' ICD-9 code form.

\begin{verbatim}
PROC FORMAT LIB=library fmtlib;
VALUE $RCOMFMT
"2780 ",
"27800",
"27801",
"27803",
"64910"-"64914",
"V8530"-"V8539",
"V8541"-"V8545",
"V8554",
"79391"         = "OBESE"     /* Obesity      */

"3004 ",
"30112",
"3090 ",
"3091 ",
"311  "         = "DEPRESS"
\end{verbatim}

This is parsed using:

<<echo=TRUE,eval=FALSE>>=
parseAhrqSas()
@

resulting in a named list. here is an extract.

<<example_ahrqComorbid>>=
ahrqComorbid[c("OBESE", "DEPRESS")]
lapply(ahrqComorbid[c("OBESE", "DEPRESS")], icd9ChildrenShort)
@

\section{Elixhauser co-morbidities}

Elixhauser originally devleoped this set of co-morbidities to predict long term mortality based on hospital ICD-9-CM coding records. The AHRQ comorbidities are an updated version of this, however the original Elixhauser have been used in many publications. The ICD-9-CM codes have changed slightly over the years.

<<elix>>=
names(elixhauserComorbid)
@

\section{Quan}

Quan's paper looked at indices using both ICD-10 and ICD-9-CM. Quan generated updated ICD-9-CM codes for all 30 of Elixhauser and all 17 of Charlson/Deyo's co-morbidities. Thus there are two 'Quan' comorbidity mappings.
<<quanElix>>=
names(quanDeyoComorbid)
names(quanElixhauserComorbid)
@


\end{document}
